# 目录
* [JDK8新特性](#jdk8新特定)
  * [Lambda表达式](#lambda表达式)
  * [接口增强](#接口增强)
  * [方法引用](#方法引用)
  * [Stream流](#stream流)
  * [日期跟时间](#日期跟时间)
  * [重复注解和类型注解](#重复注解和类型注解)
* []()

# JDK8新特定
## Lambda表达式
### 语法

格式有三部分组成：

- 参数列表: (参数类型 参数名)
- 方法体: {代码;}
- 箭头: ->, 用于分割参数列表和方法体

### 练习

无参无返回值

```
    // 形式一
    getShow(() -> {
        System.out.println("用户接口的无参无返回值方法");
    });
    
    // 形式二
    getShow(() -> System.out.println("用户接口的无参无返回方法实现形式二"));
```
无参有返回值

```
    // 无参有返回值形式一
    getName(() -> {
        return "无参有返回值实现形式一";
    });
    getName(() -> "无参有返回值实现形式二");
```

有参无返回值

```
    // 有参无返回值
    getConsumer(s -> System.out.println(s));
```

有参有返回



1. 如果参数列表中的参数只有一个，我们就可以省略参数的类型，并且可以去掉小括号不写。
2. 如果参数列表中没有参数，则必须要加上小括号
3. 如果参数列表中的参数不止一个并且参数的类型不一致则必须要加上参数的类型
4. 方体里面如果只有一条语句的话可以省略掉大括号
5. 如果方法体里面只有一条return语句的话return可以省略不写

### @FunctionalInterface注解

如果在接口上面加了`@FunctionalInterface`这个注解，那么这个接口就被申明为是函数式接口，并且这个接口里面**只能有一个抽象方法**

### 使用条件

1. 方法的参数或者局部变量的类型必须为**接口**才能使用Lambda表达式
2. 接口中有且只能有一个抽线方法(`@FunctionalInterface`)

### Lambada表达式和匿名内部类的区别

1. 所需类型不同
   - 匿名内部类可以是类、抽象类、接口
   - Lambda表达式只能是接口
2. 抽象方法数量不同
    - 匿名内部类的接口中可以有任意数量的抽象方法
    - Lambda表达式所需的接口只能有一个抽象方法
3. 实现原理不同
    - 匿名内部类编译后就会生成一个class文件
    - lambda表达式是在程序运行时动态生成class文件的

## 接口增强

### 功能变化
JDK8之前

```
    interface {
        静态常量;
        抽象方法;
    }
```

JDK8增加了**默认方法和静态方法**
```
    interface{
        静态常量;
        抽象方法;
        默认方法;
        静态方法;
    }
```

### 默认方法
```
    interface 接口名 {
        修饰符 default 返回值类型 方法名() {
            方法体;
        }
    }
```
默认方法使用方法：

1. 实现类直接调用接口的默认方法
2. 实现类可以重写接口中的默认方法

### 接口中的静态方法

```
    interface 接口名{
        修饰符 static 返回值类型 方法名{
            方法体；
        }
    }
```
静态方法的使用：

接口中的静态方法在实习类中不是能被重写的，调用的话只能通过接口名来实现：接口名.静态方法名()；

### 默认方法和静态方法的区别
1. 默认方法通过实例调用，静态方法是通过接口名进行调用
2. 默认方法可以被继承，实现类可以直接调用接口的默认方法，也可以重写接口的默认方法
3. 静态方法不能被继承，实现类不能重写接口的静态方法，只能使用接口名进行调用

## 函数式接口

### Supplier
该函数式接口是一个无参有返回值的接口，对于的Lambda表达式需要提供一个返回数据的类型


### Consumer

### Function

### Predicate


## 方法引用
## Stream流
## 日期跟时间
## 重复注解和类型注解