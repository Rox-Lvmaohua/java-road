# 设计模式复习之路

## 创建型设计模式

### 单例模式

总结：

- 饿汉式：饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以 instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
- 懒汉式：相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。
- 双重检测：双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。
- 静态内部类：利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。
- 枚举方式：最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性(同时阻止了反射和序列化对单例的破坏)。


### 工厂模式

定义：工厂方法使一个产品类的实例延迟到其工厂的子类（定义一个接口，让子类决定实例化哪个接口的实现类）。

目的：封装对象的创建过程，提升创建对象的可复用性。

主要角色

- 抽象工厂：提供创建产品的接口，调用者通过访问接口访问具体工厂的工厂方法来创建产品。
- 具体工厂：实现抽象工厂的抽象方法，完成具体产品的创建。
- 抽象产品：定义了产品的规范，描述了产品的主要特性和功能。
- 具体产品 ：实现了抽象产品所定义的接口，由具体工厂创建，它与具体工厂之间一一对应。

特点：**一个具体工厂只生产一个具体产品**

总结：**工厂方法模优缺点**
- 优点：
  1. 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
  2. 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
- 缺点：
  1.每增加一个产品就**要增加一个具体产品类和一个对应的具体工厂类**，这增加了系统的复杂度。

应用场景:
- 需要使用很多重复代码创建对象时，比如，DAO 层的数据对象、API 层的 VO 对象等。
- 创建对象要访问外部信息或资源时，比如，读取数据库字段，获取访问授权 token 信息，配置文件等。
- 创建需要统一管理生命周期的对象时，比如，会话信息、用户网页浏览轨迹对象等。
- 创建池化对象时，比如，连接池对象、线程池对象、日志对象等。这些对象的特性是：有限、可重用，使用工厂方法模式可以有效节约资源。
- 希望隐藏对象的真实类型时，比如，不希望使用者知道对象的真实构造函数参数等。


### 抽象工厂模式
定义：提供一个生产一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

> 抽象工厂模式比工厂方法模式的抽象程度更高。在工厂方法模式中每一个具体工厂只需要生产一种具体产品，但是在抽象工厂模式中一个具体工厂可以生产一组相关的具体产品，这样一组产品被称为产品族。产品族中的每一个产品都分属于某一个产品继承等级结构。

特点：抽象工厂模式中一个具体工厂能生产一组相关的具体产品（抽象工厂中的具体工厂负责生产一个产品族）
- 一组相关的具体产品（如海尔旗下的众多调味品）。
- 产品等级结构：每一个产品族都分属于某一个产品继承等级结构（如耗油下的多种品牌）。
![img.png](img.png)

主要角色：
- 抽象工厂：提供创建产品的接口，调用者通过访问接口访问具体工厂的工厂方法来创建产品 。
- 具体工厂：实现抽象工厂的抽象方法，完成具体产品的创建。
- 抽象产品：定义了产品的规范，描述了产品的主要特性和功能。
- 具体产品 ：实现了抽象产品所定义的接口，由具体工厂创建，它与具体工厂之间是一对多关系 （一个具体工厂生产多件产品）。

总结：

优点：

- 对于不同产品系列有比较多共性特征时，可以使用抽象工厂模式，有助于提升组件的复用性。
- 当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能有效地将代码统一到一个级别上。
- 解决跨平台带来的兼容性问题。


缺点：

- 增加新的产品等级结构麻烦,需要对原有结构进行较大的修改,甚至需要修改抽象层代码,这显然会带来较大不变,违背了开闭原则。

应用场景：抽象工厂模式向使用（客户）方隐藏了下列变化：

1. 程序所支持的实例集合（具体工厂）的数目；
2. 当前是使用的实例集合中的哪一个实例；
3. 在任意给定时刻被实例化的具体类型；

**要牢记“如何找到某一个类产品的正确共性功能”这个重点。**

