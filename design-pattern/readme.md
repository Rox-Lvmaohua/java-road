# 设计模式复习之路

## 创建型设计模式

### 单例模式

总结：

- 饿汉式：饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以 instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
- 懒汉式：相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。
- 双重检测：双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。
- 静态内部类：利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。
- 枚举方式：最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性(同时阻止了反射和序列化对单例的破坏)。


### 工厂模式

定义：工厂方法使一个产品类的实例延迟到其工厂的子类（定义一个接口，让子类决定实例化哪个接口的实现类）。

目的：封装对象的创建过程，提升创建对象的可复用性。

主要角色

- 抽象工厂：提供创建产品的接口，调用者通过访问接口访问具体工厂的工厂方法来创建产品。
- 具体工厂：实现抽象工厂的抽象方法，完成具体产品的创建。
- 抽象产品：定义了产品的规范，描述了产品的主要特性和功能。
- 具体产品 ：实现了抽象产品所定义的接口，由具体工厂创建，它与具体工厂之间一一对应。

特点：**一个具体工厂只生产一个具体产品**

总结：**工厂方法模优缺点**
- 优点：
  1. 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
  2. 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
- 缺点：
  1.每增加一个产品就**要增加一个具体产品类和一个对应的具体工厂类**，这增加了系统的复杂度。

应用场景:
- 需要使用很多重复代码创建对象时，比如，DAO 层的数据对象、API 层的 VO 对象等。
- 创建对象要访问外部信息或资源时，比如，读取数据库字段，获取访问授权 token 信息，配置文件等。
- 创建需要统一管理生命周期的对象时，比如，会话信息、用户网页浏览轨迹对象等。
- 创建池化对象时，比如，连接池对象、线程池对象、日志对象等。这些对象的特性是：有限、可重用，使用工厂方法模式可以有效节约资源。
- 希望隐藏对象的真实类型时，比如，不希望使用者知道对象的真实构造函数参数等。
